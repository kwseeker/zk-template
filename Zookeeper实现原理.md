# ZooKeeper实现原理

一个开源的分布式应用程序协调服务器，其为分布式系统提供**一致性服务**。其一致性是通过基于 Paxos 算法的
ZAB 协议完成的。其主要功能包括:配置维护、域名服务、分布式同步、集群管理等。

ZK节点结构：树状结构。

ZK特点：

+ **顺序一致性**:zk 接收到的 N 多个事务请求(写操作请求),其会被严格按照接收顺序应
  用到 zk 中。
+ **原子性**:所有事务请求的结果在 zk 集群中每一台主机上的应用情况都是一致的。要么
  全部应用成功,要么全部失败。
+ **单一视图**:无论 Client 连接的是 zk 集群中的哪个主机,其看到的数据模型都是一致的。
+ **可靠性**:一旦 zk 成功应用了某事务,那么该事务所引发的 zk 状态变更会被一直保留下
  来,直到另一个事务将其修改。
+ **最终一致性**:一旦一个事务被成功应用,zk 可以保证在一个很短暂时间后,Client 最终
  能够从 zk 上读取到最新的数据状态。注意,不能保证实时读取到。

## 基础理论

### Paxos算法

保证分布式系统就某个决议达成一致。

Paxos 算法的前提是不存在拜占庭将军问题（信道不安全）,即信道是安全的、可靠的,集群节点间传
递的消息是不会被篡改的。

一般情况下,分布式系统中各个节点间采用两种通讯模型:共享内存(Shared Memory，存在单点问题)
、消息传递(Messages Passing，如网络；去中心化)。而 Paxos 是基于消息传递通讯模型的。

**三种角色**：

+ Proposer：提案者（一个或多个）
+ Acceptor：表决者（多个，超过半数同意才能通过提案）。
+ Learner：学习者,同步者。

**Paxos 3PC**（和数据库事务控制３PC类似但不同）:

+ prepare 阶段（面对直到有半数表决者同意为止）
+ accept 阶段（面对全部表决者）
+ commit 阶段（让全部表决者更新本地提案信息）

**Paxos活锁问题**：

比如有两个节点A、B，Ａ先发出一个提案（N=1）,A、Ｂ在prepare阶段都表决通过，本地maxN都更新为１然后时间片耗尽；然后Ｂ提出一个提案（N=2），A、Ｂ在prepare阶段都表决通过，本地maxN都更新为２然后时间片耗尽；这时继续执行第一个未完成的提案，在accept阶段，Ａ再次表决发现maxN>1，提案失效，然后Ａ重新提交提案(N=3)然后时间片耗尽；继续执行Ｂ的提案，accept阶段发现maxN>2,提案失效，然后Ｂ重新提交提案（N=4）, 然后A、Ｂ、A、Ｂ...重复提交和失败。

Fast Paxos算法解决活锁：只允许一个进程提交提案。

### Paxos实现

#### ZAB（Zookeeper Atomic Broadcast）

专为ZK设计的一种支持崩溃恢复的原子广播协议，在ZK中，主要依赖ZAB协议实现分布式数据一致性。

ZK使用一个单一主进程（Leader, 唯一的提案者）来接收并处理客户端的所有事务请求,即写请求,解决了活锁问题。

当服务器数据的状态发生变更（写请求）后,集群采用 ZAB 原子广播协议,以事务提案 Proposal 的形式广
播到所有的副本进程上。ZAB 协议能够保证一个全局的变更序列,即可以为每一个事务分配
一个全局的递增编号 xid。

若客户端提交的是读请求,那么当前节点就直接根据自己保存的数据对其进行响应;

如果是写请求且当前节点不是Leader,那么节点就会将该写请求转发给 Leader,Leader 会以提案的方式广播该写操作,只要有超过半数节点同意该写操作,则该写操作请求就会被提交。然后 Leader 会再次广播给所有订阅者,即 Learner,通知它们同步数据。

<u>zk 集群对于事务请求的处理是 Fast Paxos 算法的体现,即只允许 Leader 提出提案</u>。其属于 3PC 提交。
但 <u>Leader 选举是 Paxos 算法的体现,因为 Leader 宕机后,所有 Follower 均可提交提案</u>,它们在最初都是“我选我”。其属于 2PC 提交。

##### 三种角色：

+ Leader：事务请求（写）唯一处理者（需要Follower表决支持），也可以处理读请求；
+ Follower：处理读请求，写请求转发给Leader,  Leader挂掉后可以参与Leader选举可被选举为Leader；
+ Observer：和Follower工作相同，但是没有表决权和选举权。

Leader好比项目经理，Follower好比正式员工，Observer好比外包员工，项目经理离职了，可以从内部员工中选出新的项目经理。

Paxos Learner：学习者,同步者。Learner = Follower + Observer
QuorumPeer = Participant = Leader + Follower

##### 三个数据

+ zxid (事务ID) :64 位长度的 Long 类型,其高 32 位为 epoch,低 32 位为 xid
+ epoch (?): 每一个新的 Leader 都会有一个新的 epoch
+ xid (纯事务ID):其为一个流水号

##### 四种状态

+ LOOKING：选举状态
+ FOLLOWING：Follower 的正常工作状态
+ OBSERVING：Observer 的正常工作状态
+ LEADING：Leader 的正常工作状态

ZK一旦一个提案通过，在这个提案提交之前，所有参与同意此提案的节点都不能继续对其他提案进行表决。是通过状态控制实现的，但是并不是对应上面四个状态，从而避免了之前的通过的提案还没处理完就被新提案给“截胡”的问题（比如解决Leader选举commit阶段截胡问题）。

##### 三个模式

+ 恢复模式：其包含两个重要阶段:Leader 的选举,与初始化同步
+ 广播模式：其可以分为两类:初始化广播,与更新广播
+ 同步模式：其可以分为两类:初始化同步,与更新同步



疑问：

１）Observer这种角色主要是做什么的？可以保持同样负载能力下，减少选举和表决压力，即并不需要太多拥有表决权和选举权的节点，否则可能导致表决和选举效率低下。

## ZK实现原理



## 8种常用业务场景



